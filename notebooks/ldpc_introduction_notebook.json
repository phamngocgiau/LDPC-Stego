{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# LDPC Steganography System - Introduction\n",
    "\n",
    "This notebook introduces the LDPC (Low-Density Parity-Check) steganography system and demonstrates its key concepts.\n",
    "\n",
    "## Table of Contents\n",
    "1. [Introduction to LDPC Codes](#introduction)\n",
    "2. [System Architecture](#architecture)\n",
    "3. [Basic LDPC Operations](#basic-operations)\n",
    "4. [Adaptive Redundancy](#adaptive-redundancy)\n",
    "5. [Performance Comparison](#performance)\n",
    "6. [Visual Demonstrations](#visual-demos)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import sys\n",
    "import os\n",
    "sys.path.append('..')\n",
    "\n",
    "import torch\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from pathlib import Path\n",
    "\n",
    "# Import our LDPC system\n",
    "from configs.ldpc_config import LDPCConfig\n",
    "from core.adaptive_ldpc import AdaptiveLDPC, create_ldpc_system\n",
    "from core.ldpc_generator import LDPCGenerator\n",
    "from core.ldpc_encoder import LDPCEncoder\n",
    "from core.ldpc_decoder import LDPCDecoder\n",
    "\n",
    "# Set up plotting\n",
    "plt.style.use('seaborn-v0_8')\n",
    "sns.set_palette(\"husl\")\n",
    "%matplotlib inline\n",
    "\n",
    "print(\"📚 LDPC Steganography System - Introduction Notebook\")\n",
    "print(\"🔧 All libraries imported successfully!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Introduction to LDPC Codes {#introduction}\n",
    "\n",
    "LDPC (Low-Density Parity-Check) codes are a class of linear error-correcting codes that can approach the Shannon limit. They are characterized by:\n",
    "\n",
    "- **Sparse parity-check matrices**: Most elements are zero\n",
    "- **Iterative decoding**: Using belief propagation algorithms\n",
    "- **Near-optimal performance**: Close to theoretical limits\n",
    "- **Flexible code rates**: Adaptable redundancy levels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a simple LDPC code for demonstration\n",
    "print(\"🔨 Creating LDPC Code Example\")\n",
    "\n",
    "# Parameters\n",
    "n = 255  # Codeword length\n",
    "k = 128  # Information bits\n",
    "rate = k / n\n",
    "\n",
    "print(f\"Code parameters:\")\n",
    "print(f\"  n (codeword length): {n}\")\n",
    "print(f\"  k (information bits): {k}\")\n",
    "print(f\"  r (parity bits): {n-k}\")\n",
    "print(f\"  Code rate: {rate:.3f}\")\n",
    "print(f\"  Redundancy: {(1-rate)*100:.1f}%\")\n",
    "\n",
    "# Generate LDPC code\n",
    "ldpc_gen = LDPCGenerator(n=n, k=k, seed=42, construction=\"gallager\")\n",
    "\n",
    "print(f\"\\n✅ LDPC code generated successfully!\")\n",
    "print(f\"H matrix shape: {ldpc_gen.H.shape}\")\n",
    "print(f\"H matrix density: {np.sum(ldpc_gen.H) / (ldpc_gen.H.shape[0] * ldpc_gen.H.shape[1]):.4f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize the LDPC parity-check matrix\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
    "\n",
    "# Full matrix visualization\n",
    "im1 = ax1.imshow(ldpc_gen.H, cmap='Blues', aspect='auto')\n",
    "ax1.set_title('LDPC Parity-Check Matrix H')\n",
    "ax1.set_xlabel('Variable Nodes (n)')\n",
    "ax1.set_ylabel('Check Nodes (r)')\n",
    "plt.colorbar(im1, ax=ax1)\n",
    "\n",
    "# Zoomed view of corner\n",
    "corner_size = min(50, ldpc_gen.H.shape[0], ldpc_gen.H.shape[1])\n",
    "im2 = ax2.imshow(ldpc_gen.H[:corner_size, :corner_size], cmap='Blues')\n",
    "ax2.set_title(f'H Matrix (First {corner_size}x{corner_size})')\n",
    "ax2.set_xlabel('Variable Nodes')\n",
    "ax2.set_ylabel('Check Nodes')\n",
    "plt.colorbar(im2, ax=ax2)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Matrix properties\n",
    "properties = ldpc_gen.get_properties()\n",
    "print(\"\\n📊 LDPC Matrix Properties:\")\n",
    "for key, value in properties.items():\n",
    "    if isinstance(value, float):\n",
    "        print(f\"  {key}: {value:.3f}\")\n",
    "    else:\n",
    "        print(f\"  {key}: {value}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. System Architecture {#architecture}\n",
    "\n",
    "Our LDPC steganography system consists of several key components:\n",
    "\n",
    "1. **Adaptive LDPC System**: Dynamically adjusts redundancy based on attack strength\n",
    "2. **Neural Network Models**: Encoder and decoder networks\n",
    "3. **Recovery System**: CVAE for image recovery after attacks\n",
    "4. **Attack Simulation**: Training against various attacks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create the complete adaptive LDPC system\n",
    "print(\"🏗️ Building Adaptive LDPC System\")\n",
    "\n",
    "config = LDPCConfig()\n",
    "config.message_length = 1024\n",
    "config.device = 'cpu'\n",
    "config.ldpc_min_redundancy = 0.1\n",
    "config.ldpc_max_redundancy = 0.5\n",
    "\n",
    "# Create adaptive LDPC system\n",
    "adaptive_ldpc = create_ldpc_system(config)\n",
    "\n",
    "print(f\"✅ Adaptive LDPC System Created\")\n",
    "print(f\"  Message length: {adaptive_ldpc.message_length}\")\n",
    "print(f\"  Redundancy range: {adaptive_ldpc.min_redundancy:.1f} - {adaptive_ldpc.max_redundancy:.1f}\")\n",
    "print(f\"  Available redundancy levels: {len(adaptive_ldpc.redundancy_levels)}\")\n",
    "print(f\"  Levels: {[f'{r:.2f}' for r in adaptive_ldpc.redundancy_levels]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize the system architecture\n",
    "fig, ax = plt.subplots(1, 1, figsize=(12, 8))\n",
    "\n",
    "# Create a flowchart-style diagram\n",
    "from matplotlib.patches import Rectangle, FancyBboxPatch\n",
    "from matplotlib.patches import ConnectionPatch\n",
    "\n",
    "# Define boxes\n",
    "boxes = {\n",
    "    'Cover Image': (1, 7, 2, 1),\n",
    "    'Message': (1, 5, 2, 1),\n",
    "    'LDPC Encoder': (4, 5, 2, 1),\n",
    "    'Neural Encoder': (7, 6, 2, 1),\n",
    "    'Stego Image': (10, 6, 2, 1),\n",
    "    'Attack/Channel': (10, 4, 2, 1),\n",
    "    'Attacked Stego': (10, 2, 2, 1),\n",
    "    'Neural Decoder': (7, 2, 2, 1),\n",
    "    'LDPC Decoder': (4, 2, 2, 1),\n",
    "    'Recovered Message': (1, 2, 2, 1)\n",
    "}\n",
    "\n",
    "# Draw boxes\n",
    "for label, (x, y, w, h) in boxes.items():\n",
    "    if 'LDPC' in label:\n",
    "        color = 'lightblue'\n",
    "    elif 'Neural' in label:\n",
    "        color = 'lightgreen'\n",
    "    elif 'Attack' in label:\n",
    "        color = 'lightcoral'\n",
    "    else:\n",
    "        color = 'lightyellow'\n",
    "    \n",
    "    box = FancyBboxPatch((x, y), w, h, boxstyle=\"round,pad=0.1\", \n",
    "                        facecolor=color, edgecolor='black', linewidth=1)\n",
    "    ax.add_patch(box)\n",
    "    ax.text(x + w/2, y + h/2, label, ha='center', va='center', fontsize=10, weight='bold')\n",
    "\n",
    "# Draw arrows\n",
    "arrows = [\n",
    "    ((3, 5.5), (4, 5.5)),  # Message -> LDPC Encoder\n",
    "    ((6, 5.5), (7, 6.2)),  # LDPC Encoder -> Neural Encoder\n",
    "    ((3, 7.5), (7, 6.8)),  # Cover -> Neural Encoder\n",
    "    ((9, 6.5), (10, 6.5)), # Neural Encoder -> Stego\n",
    "    ((11, 6), (11, 5)),    # Stego -> Attack\n",
    "    ((11, 4), (11, 3)),    # Attack -> Attacked Stego\n",
    "    ((10, 2.5), (9, 2.5)), # Attacked Stego -> Neural Decoder\n",
    "    ((7, 2.5), (6, 2.5)),  # Neural Decoder -> LDPC Decoder\n",
    "    ((4, 2.5), (3, 2.5)),  # LDPC Decoder -> Recovered\n",
    "]\n",
    "\n",
    "for start, end in arrows:\n",
    "    ax.annotate('', xy=end, xytext=start, \n",
    "               arrowprops=dict(arrowstyle='->', lw=2, color='darkblue'))\n",
    "\n",
    "ax.set_xlim(0, 13)\n",
    "ax.set_ylim(1, 9)\n",
    "ax.set_aspect('equal')\n",
    "ax.axis('off')\n",
    "ax.set_title('LDPC Steganography System Architecture', fontsize=16, weight='bold', pad=20)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Basic LDPC Operations {#basic-operations}\n",
    "\n",
    "Let's demonstrate the basic encoding and decoding operations of LDPC codes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Demonstrate basic LDPC encoding and decoding\n",
    "print(\"🔧 LDPC Encoding and Decoding Demonstration\")\n",
    "\n",
    "# Generate a random message\n",
    "np.random.seed(42)\n",
    "message_length = config.message_length\n",
    "original_message = torch.randint(0, 2, (1, message_length), dtype=torch.float32)\n",
    "\n",
    "print(f\"Original message length: {message_length}\")\n",
    "print(f\"Original message (first 20 bits): {original_message[0][:20].int().tolist()}\")\n",
    "\n",
    "# Encode with different attack strengths\n",
    "attack_strengths = [0.1, 0.3, 0.5]\n",
    "results = {}\n",
    "\n",
    "for attack_strength in attack_strengths:\n",
    "    # Encode\n",
    "    encoded_message = adaptive_ldpc.encode(original_message, attack_strength)\n",
    "    \n",
    "    # Get code information\n",
    "    code_info = adaptive_ldpc.get_code_info(attack_strength)\n",
    "    \n",
    "    # Add some noise to simulate channel errors\n",
    "    noise_std = attack_strength * 0.2\n",
    "    noisy_encoded = encoded_message + torch.randn_like(encoded_message) * noise_std\n",
    "    \n",
    "    # Decode\n",
    "    decoded_message = adaptive_ldpc.decode(noisy_encoded, attack_strength)\n",
    "    \n",
    "    # Calculate accuracy\n",
    "    original_bits = (original_message > 0.5).float()\n",
    "    decoded_bits = (decoded_message > 0.5).float()\n",
    "    accuracy = (original_bits == decoded_bits).float().mean().item()\n",
    "    \n",
    "    results[attack_strength] = {\n",
    "        'redundancy': code_info['redundancy'],\n",
    "        'code_rate': code_info['rate'],\n",
    "        'expansion_factor': code_info['expansion_factor'],\n",
    "        'encoded_length': encoded_message.shape[1],\n",
    "        'accuracy': accuracy,\n",
    "        'noise_std': noise_std\n",
    "    }\n",
    "    \n",
    "    print(f\"\\n📊 Attack Strength: {attack_strength}\")\n",
    "    print(f\"  Redundancy: {code_info['redundancy']:.2f}\")\n",
    "    print(f\"  Code rate: {code_info['rate']:.3f}\")\n",
    "    print(f\"  Encoded length: {encoded_message.shape[1]}\")\n",
    "    print(f\"  Expansion factor: {code_info['expansion_factor']:.2f}x\")\n",
    "    print(f\"  Noise std: {noise_std:.3f}\")\n",
    "    print(f\"  Decoding accuracy: {accuracy:.1%}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize the encoding/decoding results\n",
    "fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))\n",
    "\